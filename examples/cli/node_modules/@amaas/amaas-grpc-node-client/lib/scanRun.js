"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanRun = void 0;
const path = require("path");
const fs = require("fs");
const scanPb = require("./scan_pb");
const logger_1 = require("./logger");
/**
 * scanRun - the grpc scanRun
 * @param {ScanClient} scanClient: the scan client
 * @param {string} fileName: the file name to scan
 * @param {number} fileSize: the size of the file
 */
const scanRun = (scanClient, fileName, fileSize) => new Promise((resolve, reject) => {
    logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.debug(`scanRun() called, fileName: ${fileName}, fileSize: ${fileSize}`);
    try {
        const fd = fs.openSync(fileName, 'r');
        let _finiResult = '';
        let _error;
        const stream = scanClient.run();
        stream.on('data', (response) => {
            if (response.getCmd() === scanPb.Command.CMD_RETR && response.getLength() > 0) {
                logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.debug(`stream on data: length: ${response.getLength()}, offset: ${response.getOffset()}`);
                const buf = Buffer.alloc(response.getLength(), 0);
                try {
                    fs.readSync(fd, buf, 0, response.getLength(), response.getOffset());
                }
                catch (err) {
                    if (err) {
                        const errMsg = `Failed to retrieve data from file:: ${err}`;
                        logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.error(errMsg);
                        _error = new Error(errMsg);
                        stream.end();
                    }
                }
                const request = new scanPb.C2S();
                request.setStage(scanPb.Stage.STAGE_RUN);
                request.setOffset(response.getOffset());
                request.setChunk(buf);
                stream.write(request, (err) => {
                    if (err) {
                        const errMsg = `Failed to send data chunk: ${err}`;
                        _error = new Error(errMsg);
                    }
                });
            }
            else if (response.getCmd() === scanPb.Command.CMD_QUIT) {
                const resultJson = JSON.parse(response.getResult());
                resultJson.fileName = path.basename(fileName);
                resultJson.filePath = fileName.replace(resultJson.fileName, '');
                response.setResult(JSON.stringify(resultJson));
                _finiResult = response.getResult();
                stream.end();
            }
            else {
                const errMsg = `Received unknown command from server: ${response.getCmd()}`;
                logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.error(errMsg);
                _error = new Error(errMsg);
                stream.end();
            }
        });
        stream.on('error', (err) => {
            if (!_error) {
                _error = err;
            }
            if (_error.message.indexOf('Metadata key ""') >= 0) {
                const errMsg = `Failed to setup stream: authorization key is ''`;
                _error = new Error(errMsg);
            }
            logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.error(_error);
        });
        stream.on('end', () => {
            logger_1.logger === null || logger_1.logger === void 0 ? void 0 : logger_1.logger.debug('scanRun(), stream closed');
            fs.closeSync(fd);
            _error ? reject(_error) : resolve(JSON.parse(_finiResult));
        });
        const initRequest = new scanPb.C2S();
        initRequest.setStage(scanPb.Stage.STAGE_INIT);
        initRequest.setFileName(fileName);
        initRequest.setRsSize(fileSize);
        stream.write(initRequest, (err) => {
            if (err) {
                const errMsg = `Failed to send data chunk: ${err}`;
                _error = new Error(errMsg);
                stream.end();
            }
        });
    }
    catch (err) {
        reject(err);
    }
});
exports.scanRun = scanRun;
