import * as path from 'path'
import * as fs from 'fs'

import * as scanPb from './scan_pb'
import { ScanClient } from './scan_grpc_pb'
import { AmaasScanResultObject } from './amaasScanResultObject'
import { logger } from './logger'
import { Deadline } from '@grpc/grpc-js'

/**
 * Running scan client
 * @param {ScanClient} scanClient scan client
 * @param {string} fileName file to scan
 * @param {number} fileSize size of the file
 * @param {number} timeout number in seconds to wait before closing the connection
 */
export const scanRun = (
  scanClient: ScanClient,
  fileName: string,
  fileSize: number,
  timeout: number
) =>
  new Promise<AmaasScanResultObject>((resolve, reject) => {
    try {
      const fd = fs.openSync(fileName, 'r')
      let _finiResult = ''
      let error: Error | undefined
      const deadline: Deadline = new Date().getTime() + timeout * 1000
      const stream = scanClient.run({ deadline })
      stream.on('data', (response: scanPb.S2C) => {
        if (
          response.getCmd() === scanPb.Command.CMD_RETR &&
          response.getLength() > 0
        ) {
          logger?.debug(
            `command CMD_RETR received, length: ${response.getLength()}, offset: ${response.getOffset()}`
          )
          const buf = Buffer.alloc(response.getLength(), 0)
          try {
            fs.readSync(fd, buf, 0, response.getLength(), response.getOffset())
          } catch (e: any) {
            if (e) {
              logger?.error(e)
              error = new Error(`Failed to retrieve data from file. ${e}`)
              stream.end()
            }
          }
          const request = new scanPb.C2S()
          request.setStage(scanPb.Stage.STAGE_RUN)
          request.setOffset(response.getOffset())
          request.setChunk(buf)
          stream.write(request, (e: Error) => {
            if (e) {
              error = new Error(`Failed to send data chunk. ${e}`)
            }
          })
        } else if (response.getCmd() === scanPb.Command.CMD_QUIT) {
          logger?.debug('command CMD_QUIT received')
          const resultJson = JSON.parse(response.getResult())
          resultJson.fileName = path.basename(fileName)
          resultJson.filePath = fileName.replace(resultJson.fileName, '')
          response.setResult(JSON.stringify(resultJson))
          _finiResult = response.getResult()
          stream.end()
        } else {
          error = new Error(
            `Received unknown command from server. ${response.getCmd()}`
          )
          stream.end()
        }
      })
      stream.on('error', e => {
        if (e.message.indexOf('Metadata key ""') >= 0) {
          error = new Error('Failed to setup stream')
        }
        error = error || e
        logger?.error(`stream on error. ${error}`)
      })
      stream.on('end', () => {
        fs.closeSync(fd)
        error ? reject(error) : resolve(JSON.parse(_finiResult))
      })

      const initRequest = new scanPb.C2S()
      initRequest.setStage(scanPb.Stage.STAGE_INIT)
      initRequest.setFileName(fileName)
      initRequest.setRsSize(fileSize)
      stream.write(initRequest, (e: Error) => {
        if (e) {
          error = new Error(`Failed to send data chunk. ${e}`)
          stream.end()
        }
      })
    } catch (e: any) {
      logger?.error(e)
      reject(e)
    }
  })
