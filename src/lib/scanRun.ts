import { basename } from 'path'
import { openSync, readSync, closeSync } from 'fs'

import * as scanPb from './scan_pb'
import { ScanClient } from './scan_grpc_pb'
import { AmaasScanResultObject } from './amaasScanResultObject'
import { logger } from './logger'
import { Deadline } from '@grpc/grpc-js'

export class ScanRun {
  protected scanClient
  protected deadline

  constructor (scanClient: ScanClient, timeout: number) {
    this.scanClient = scanClient
    this.deadline = timeout
  }

  protected async streamRun (
    fileName: string,
    fileSize: number,
    buff?: Buffer
  ): Promise<AmaasScanResultObject> {
    return await new Promise<AmaasScanResultObject>((resolve, reject) => {
      try {
        const _deadline: Deadline = new Date().getTime() + this.deadline * 1000
        let _finiResult = ''
        let error: Error
        let fd: number

        logger?.debug(
          `scanRun started. fileName: ${fileName}, fileSize: ${fileSize}, deadline: ${_deadline} ms`
        )

        if (buff === undefined) {
          try {
            fd = openSync(fileName, 'r')
          } catch (err) {
            logger?.debug(`In scanRun > openSync. ${String(err)}`)
            throw err
          }
        }

        const stream = this.scanClient.run({ deadline: _deadline })
        stream.on('data', function (response: scanPb.S2C) {
          const cmd = response.getCmd()
          const length = response.getLength()
          const offset = response.getOffset()

          if (cmd === scanPb.Command.CMD_RETR && length > 0) {
            logger?.debug(
              `command CMD_RETR received, fileName: ${fileName}, length: ${length}, offset: ${offset}`
            )

            let chunk
            if (buff !== undefined) {
              chunk = buff.subarray(offset, offset + length)
            } else {
              chunk = Buffer.alloc(length)
              try {
                readSync(fd, chunk, 0, length, offset)
              } catch (err) {
                logger?.debug(`In scanRun > readSync. ${String(err)}`)
                throw err
              }
            }
            const request = new scanPb.C2S()
            request.setStage(scanPb.Stage.STAGE_RUN)
            request.setOffset(response.getOffset())
            request.setChunk(chunk)
            stream.write(request)
          } else if (cmd === scanPb.Command.CMD_QUIT) {
            const result = response.getResult()
            logger?.debug(
              `command CMD_QUIT received, name: ${fileName}, result: ${result}`
            )
            const resultJson = JSON.parse(result)
            resultJson.fileName = basename(fileName)
            resultJson.filePath = fileName.replace(resultJson.fileName, '')
            _finiResult = JSON.stringify(resultJson)
            stream.end()
          } else {
            logger?.warn(`In scanRun, unknown command received. ${response.getCmd()}`)
            stream.end()
          }
        })
        stream.on('error', err => {
          logger?.debug(`In scanRun > stream.on(error). ${String(err)}`)

          if (['Metadata key ""'].includes(String(err))) {
            error = new Error(`Failed to setup connection to AMaaS host. ${String(err)}`)
          } else {
            error = err
          }
        })
        stream.on('end', () => {
          if (buff === undefined) {
            closeSync(fd)
          }
          if (error !== undefined) {
            reject(error)
          }
          if (_finiResult.length > 0) {
            resolve(JSON.parse(_finiResult))
          } else {
            reject(new Error('No scan result.'))
          }
        })

        // INIT stage
        const initRequest = new scanPb.C2S()
        initRequest.setStage(scanPb.Stage.STAGE_INIT)
        initRequest.setFileName(fileName)
        initRequest.setRsSize(fileSize)
        stream.write(initRequest)
      } catch (e) {
        reject(e)
      }
    })
  }

  async scanFile (
    name: string,
    size: number
  ): Promise<AmaasScanResultObject> {
    return await this.streamRun(name, size)
      .then(result => {
        return result
      })
      .catch(reason => { throw reason })
  }

  async scanBuffer (
    name: string,
    buff: Buffer
  ): Promise<AmaasScanResultObject> {
    const size = Buffer.byteLength(buff)
    return await this.streamRun(name, size, buff)
      .then(result => result)
      .catch(err => { throw err })
  }
}
