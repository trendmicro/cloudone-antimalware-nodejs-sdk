import { statSync } from 'fs'
import { status, credentials, Metadata, ServiceError } from '@grpc/grpc-js'

import { ScanClient } from './scan_grpc_pb'
import { ScanRun } from './scanRun'
import { logger } from './logger'
import { AmaasScanResultObject } from './amaasScanResultObject'
import { AmaasCredentials } from './amaasCredentials'
import { CallMetadataGenerator } from '@grpc/grpc-js/build/src/call-credentials'

/**
 * Class AmaasGrpcClient
 */
export class AmaasGrpcClient {
  protected _scanClient: ScanClient
  protected _credsKey: string
  protected _timeout: number

  /**
   * AmaasGrpcClient constructor
   * @param amaasHostName - AMaaS host name
   * @param creds - credentials to use
   * @param timeout - number in seconds to wait before closing the connection
   * @param enableTLS - enabling TLS
   */
  constructor (
    amaasHostName: string,
    creds: AmaasCredentials,
    timeout: number | undefined = 180,
    enableTLS: boolean | undefined = true
  ) {
    this._timeout = timeout
    this._credsKey = 'Authorization'

    logger?.debug(
      `initialize AmaasGrpcClient, amaasHostName: ${amaasHostName}, creds: ${JSON.stringify(creds)}, enableTLS: ${enableTLS.toString()}`
    )

    try {
      if (enableTLS) {
        const channelCreds = credentials.createSsl()
        const metaCallback: CallMetadataGenerator = (
          _params: any,
          callback: (arg0: null, arg1: any) => void
        ) => {
          const meta: Metadata = new Metadata()
          meta.add(
            this._credsKey,
            creds.credsType === 'token'
              ? `bearer ${creds.secret}`
              : `apikey ${creds.secret}`
          )
          callback(null, meta)
        }
        const callCreds =
          credentials.createFromMetadataGenerator(metaCallback)
        const combCreds = credentials.combineChannelCredentials(
          channelCreds,
          callCreds
        )
        this._scanClient = new ScanClient(amaasHostName, combCreds)
      } else {
        this._scanClient = new ScanClient(
          amaasHostName,
          credentials.createInsecure()
        )
      }
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Failed to create scan client. ${_err.message}`)
      throw new Error(`Failed to create scan client. ${_err.message}`)
    }
  }

  /**
   * Process error
   *
   * @param err - Error to process
   */
  protected processError = (err: any): Error => {
    const _err = err as ServiceError
    let message: string

    if (_err.code.toString() === 'EACCES') {
      message = `Failed to open file. ${_err.message}`
    } else {
      if (_err.code !== null) {
        switch (_err.code) {
          case status.NOT_FOUND:
            message = `The requested resource was not found. ${_err.details}`
            break
          case status.PERMISSION_DENIED:
            message = `You do not have sufficient permissions to access this resource. ${_err.details}`
            break
          case status.UNAUTHENTICATED:
            message = `You are not authenticated. ${_err.details}`
            break
          case status.DEADLINE_EXCEEDED:
            message = `The request deadline was exceeded. ${_err.details}`
            break
          default:
            message = `An unknown error occurred. ${_err.details}`
        }
      } else {
        message = _err.message
      }
    }
    return new Error(message)
  }

  /**
   * Scan file and return result
   *
   * @param name - Filename
   */
  public scanFile = async (name: string): Promise<AmaasScanResultObject> => {
    try {
      let size: number
      try {
        const stats = statSync(name)
        size = stats.size
      } catch (err: any) {
        this.close()
        const _err = err as Error
        throw new Error(`Failed to open file. ${_err.message}`)
      }
      const scanRun = new ScanRun(this._scanClient, this._timeout)
      return await scanRun
        .scanFile(name, size)
        .then(result => {
          return result
        })
        .catch(err => {
          throw this.processError(err)
        })
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Error: in scanFile(), ${_err.message}`)
      this.close()
      throw err
    }
  }

  /**
   * Scan buffer and return scan result
   *
   * @param fileName - Filename
   * @param buff - Buffer to scan
   */
  public scanBuffer = async (fileName: string, buff: Buffer): Promise<AmaasScanResultObject> => {
    try {
      const scanRun = new ScanRun(this._scanClient, this._timeout)
      return await scanRun
        .scanBuffer(fileName, buff)
        .then(result => result)
        .catch(err => {
          this.close()
          throw this.processError(err)
        })
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Error: in scanBuffer(), ${_err.message}`)
      this.close()
      throw err
    }
  }

  /**
   * Close scan client
   */
  close = (): void => {
    // Close channel
    this._scanClient.getChannel().close()

    // Close scan client
    this._scanClient.close()
  }
}
