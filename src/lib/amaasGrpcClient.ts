import { statSync } from 'fs'
import { status, credentials, Metadata, ServiceError } from '@grpc/grpc-js'

import { ScanClient } from './scan_grpc_pb'
import { ScanRun } from './scanRun'
import { logger } from './logger'
import { AmaasScanResultObject } from './amaasScanResultObject'
import { AmaasCredentials } from './amaasCredentials'
import { CallMetadataGenerator } from '@grpc/grpc-js/build/src/call-credentials'
import { isJWT } from './utils'

/**
 * Class AmaasGrpcClient
 */
export class AmaasGrpcClient {
  protected _scanClient: ScanClient
  protected _credsKey: string
  protected _timeout: number

  /**
   * AmaasGrpcClient constructor
   * @param amaasHostName - AMaaS host name
   * @param creds - AmaasCredentials object
   * @param timeout - number in seconds to wait before closing the connection
   * @param enableTLS - enabling TLS
   */
  constructor (
    amaasHostName: string,
    creds: AmaasCredentials,
    timeout?: number | undefined,
    enableTLS?: boolean | undefined
  )
  /**
   * AmaasGrpcClient constructor
   * @param amaasHostName - AMaaS host name
   * @param key - Cloud One API key or token
   * @param timeout - number in seconds to wait before closing the connection
   * @param enableTLS - enabling TLS
   */
  constructor (
    amaasHostName: string,
    key: string,
    timeout?: number | undefined,
    enableTLS?: boolean | undefined
  )
  constructor (...args: any[]) {
    const amaasHostName: string = args[0]
    const creds: string | AmaasCredentials = args[1]
    const key: string = typeof creds === 'string' ? args[1] : args[1].secret
    this._timeout = args[2] === undefined ? 180 : parseInt(args[2])
    const enableTLS: boolean = args[3] === undefined ? true : args[3]
    this._credsKey = 'Authorization'

    logger?.debug(
      `initialize AmaasGrpcClient, amaasHostName: ${amaasHostName}, key: ${key}, enableTLS: ${enableTLS.toString()}`
    )

    try {
      if (enableTLS) {
        const channelCreds = credentials.createSsl()
        const metaCallback: CallMetadataGenerator = (
          _params: any,
          callback: (arg0: null, arg1: any) => void
        ) => {
          const meta: Metadata = new Metadata()
          meta.add(
            this._credsKey,
            isJWT(key)
              ? `bearer ${key}`
              : `apikey ${key}`
          )
          callback(null, meta)
        }
        const callCreds =
          credentials.createFromMetadataGenerator(metaCallback)
        const combCreds = credentials.combineChannelCredentials(
          channelCreds,
          callCreds
        )
        this._scanClient = new ScanClient(
          amaasHostName,
          combCreds,
          { 'grpc.service_config_disable_resolution': 1 }
        )
      } else {
        this._scanClient = new ScanClient(
          amaasHostName,
          credentials.createInsecure(),
          { 'grpc.service_config_disable_resolution': 1 }
        )
      }
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Failed to create scan client. ${_err.message}`)
      throw new Error(`Failed to create scan client. ${_err.message}`)
    }
  }

  /**
   * Process error
   *
   * @param err - Error to process
   */
  protected processError (err: any): Error {
    const _err = err as ServiceError
    let message: string

    if (_err.code !== undefined) {
      if (_err.code.toString() === 'EACCES') {
        message = `Failed to open file. ${_err.message}`
      } else {
        switch (_err.code) {
          case status.NOT_FOUND:
            message = `The requested resource was not found. ${_err.details}`
            break
          case status.PERMISSION_DENIED:
            message = `You do not have sufficient permissions to access this resource. ${_err.details}`
            break
          case status.UNAUTHENTICATED:
            message = `You are not authenticated. ${_err.details}`
            break
          case status.DEADLINE_EXCEEDED:
            message = `The request deadline was exceeded. ${_err.details}`
            break
          case status.UNAVAILABLE:
            if (['HTTP Status: 429; Exceeds rate limit'].includes(_err.details)) {
              message = `Too many requests. ${_err.details}`
            } else {
              message = `Service is not reachable. ${_err.details}`
            }
            break
          default:
            message = `${_err.details}`
        }
      }
    } else {
      message = _err.message
    }

    return new Error(message)
  }

  /**
   * Scan file and return result
   *
   * @param name - Filename
   */
  async scanFile (name: string): Promise<AmaasScanResultObject> {
    try {
      let size: number
      try {
        const stats = statSync(name)
        size = stats.size
      } catch (err: any) {
        const _err = err as Error
        throw new Error(`Failed to open file. ${_err.message}`)
      }
      const scanRun = new ScanRun(this._scanClient, this._timeout)
      return await scanRun
        .scanFile(name, size)
        .then(result => result)
        .catch(err => {
          throw this.processError(err)
        })
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Error: in scanFile(), ${_err.message}`)
      throw err
    }
  }

  /**
   * Scan buffer and return scan result
   *
   * @param fileName - Filename
   * @param buff - Buffer to scan
   */
  async scanBuffer (fileName: string, buff: Buffer): Promise<AmaasScanResultObject> {
    try {
      const scanRun = new ScanRun(this._scanClient, this._timeout)
      return await scanRun
        .scanBuffer(fileName, buff)
        .then(result => result)
        .catch(err => {
          throw this.processError(err)
        })
    } catch (err) {
      const _err = err as Error
      logger?.debug(`Error: in scanBuffer(), ${_err.message}`)
      throw err
    }
  }

  /**
   * Close scan client
   */
  close = (): void => {
    // Close channel
    this._scanClient.getChannel().close()

    // Close scan client
    this._scanClient.close()
  }
}
