import { readFileSync } from 'fs'
import { loadSync } from '@grpc/proto-loader'
import * as path from 'path'
import {
  Server,
  ServerCredentials,
  loadPackageDefinition
} from '@grpc/grpc-js'
import { randomUUID } from 'crypto'

import { AmaasCredentials, AmaasGrpcClient, AmaasScanResultObject, logger } from '../src'
import * as scanPb from '../src/lib/scan_pb'
import { isJWT } from '../src/lib/utils'
import { generateJwtToken } from './utils/jwtTokens'

const jestTimeout: number = 5 * 60 * 1000 // ms
jest.setTimeout(jestTimeout)
const protoLoaderOptions = {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true
}
const scanProtoFile = path.resolve('./', 'scan.proto')
const packageDefinition = loadSync(
  scanProtoFile,
  protoLoaderOptions
)
const scanGrpcObj = loadPackageDefinition(packageDefinition)
const grpcClient = (scanGrpcObj.amaas as any).scan.v1.Scan
const grpcServiceAttrs = grpcClient.service
const serverInsecureCreds = ServerCredentials.createInsecure()

// Services implementation
const runImpl = (call: any): void => {
  // Random generated maximum number of runs in between 2 and 5
  const maxRuns = Math.floor(Math.random() * 4 + 1)
  let counts = 0
  let rsSize = 0
  let fileName: string
  const cmdQuitS2CMessage = {
    cmd: scanPb.Command.CMD_QUIT,
    stage: scanPb.Stage.STAGE_FINI,
    result: JSON.stringify({
      version: '1.0',
      scanResult: 0,
      scanId: randomUUID(),
      scanTimestamp: new Date().toUTCString(),
      foundMalwares: []
    })
  }
  call.on('data', (request: any) => {
    const stage: string = request.stage
    if (stage === 'STAGE_INIT') {
      rsSize = request.rs_size
      fileName = request.file_name

      // Returns CMD_QUIT if request's rs_size is zero
      if (rsSize === 0) {
        call.write(cmdQuitS2CMessage)
        call.end()
      } else {
        // Random generated length in between 1 and rs_size
        const length = Math.ceil(Math.random() * rsSize)
        logger?.debug(`Server runImpl, stage: ${stage}, file_name: ${fileName}, rs_size: ${rsSize}, length: ${length}`)
        call.write({ cmd: scanPb.Command.CMD_RETR, stage: scanPb.Stage.STAGE_RUN, length })
      }
    } else if (stage === 'STAGE_RUN') {
      // Send CMD_QUIT if maximum number of runs is reached
      if (counts >= maxRuns) {
        call.write(cmdQuitS2CMessage)
        call.end()
      } else {
        counts += 1
        const length = Math.ceil(Math.random() * rsSize)
        logger?.debug(
          `Server runImpl stage: ${stage}, file_name: ${fileName}, rs_size: ${rsSize}, length: ${length}`
        )
        call.write({ cmd: scanPb.Command.CMD_RETR, stage: scanPb.Stage.STAGE_RUN, length })
      }
    } else {
      // other stages
      call.end()
    }
  })
  call.on('end', () => {
    call.end()
  })
}
const scanImpls = {
  Run: runImpl
}

// Mock server does not use TLS protocol. Set enableTLS to false.
const enableTLS = false
const grpcConnectionTimeout = 3 * 60 // seconds
const amaasHostName = 'localhost:50051'
const authKey = ''
const cred: AmaasCredentials = {
  credsType: 'apikey',
  secret: authKey
}
const filesToScan = ['package-lock.json', 'jest.config.ts', 'scan.proto']

// Disable NodeJS gRPC DNS resolution when localhost is used to fix process doesn't exit immediately issue
const server = new Server({ 'grpc.service_config_disable_resolution': 1 })

beforeAll(done => {
  server.addService(grpcServiceAttrs, scanImpls)
  server.bindAsync(amaasHostName, serverInsecureCreds, (err, port) => {
    if (err != null) {
      done(err)
      return
    }
    server.start()
    logger?.debug(`Server started on port ${port}`)
    done()
  })
})

afterAll(() => {
  server.tryShutdown(err => {
    if (err !== undefined) {
      return
    }
    logger?.debug('Server shutdown')
  })
})

describe('AmaasGrpcClient class constructor testing', () => {
  it('should initiate class successfully with key', () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey)
    expect(amaasGrpcClient).toBeDefined()
    amaasGrpcClient.close()
  })

  it('should initiate class successfully with key and non-default params', () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    expect(amaasGrpcClient).toBeDefined()
    amaasGrpcClient.close()
  })

  it('should initiate class successfully with credential object', () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, cred)
    expect(amaasGrpcClient).toBeDefined()
    amaasGrpcClient.close()
  })

  it('should initiate class successfully with  credential object and non-default params', () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, cred, grpcConnectionTimeout, enableTLS)
    expect(amaasGrpcClient).toBeDefined()
    amaasGrpcClient.close()
  })
})

describe('AmaasGrpcClient scanFile function testing', () => {
  it('should scan file successfully', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    await expect(amaasGrpcClient.scanFile(filesToScan[0])).resolves.toBeDefined()
    amaasGrpcClient.close()
  })

  it('should successfully scan file sequentially', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    const filesArray = filesToScan.slice(1)
    const results: AmaasScanResultObject[] = []
    const lastResult = await filesArray.reduce(
      async (promised, current) => {
        await promised.then(result => {
          results.push(result)
        })
        return await amaasGrpcClient.scanFile(current)
      },
      amaasGrpcClient.scanFile(filesToScan[0])
    )
    amaasGrpcClient.close()
    results.push(lastResult)
    expect(results.length).toEqual(filesToScan.length)
    results.forEach(result => {
      expect(result).toBeDefined()
    })
  })

  it('should successfully scan file concurrently', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    const actions = filesToScan.map(async file => {
      return await amaasGrpcClient.scanFile(file)
    })
    await Promise.all(actions)
      .then(results => {
        results.forEach(result => {
          expect(result).toBeDefined()
        })
      })
    amaasGrpcClient.close()
  })
})

describe('AmaasGrpcClient scanBuffer function testing', () => {
  it('should scan buffer successfully', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    const buff = readFileSync(filesToScan[0])
    await expect(amaasGrpcClient.scanBuffer(filesToScan[0], buff)).resolves.toBeDefined()
    amaasGrpcClient.close()
  })

  it('should successfully scan buffer sequentially', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    const fileArray = filesToScan.slice(1)
    const results: AmaasScanResultObject[] = []
    const lastResult = await fileArray.reduce(
      async (promised, current) => {
        await promised.then(result => {
          results.push(result)
        })
        const buff = readFileSync(current)
        return await amaasGrpcClient.scanBuffer(current, buff)
      },
      amaasGrpcClient.scanBuffer(filesToScan[0], readFileSync(filesToScan[0]))
    )
    amaasGrpcClient.close()
    results.push(lastResult)
    expect(results.length).toEqual(filesToScan.length)
    results.forEach(result => {
      expect(result).toBeDefined()
    })
  })

  it('should successfully scan buffer concurrently', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, grpcConnectionTimeout, enableTLS)
    const buffArray = filesToScan.map(file => {
      return { name: file, buff: readFileSync(file) }
    })
    const actions = buffArray.map(async buffObj => {
      return await amaasGrpcClient.scanBuffer(buffObj.name, buffObj.buff)
    })
    await Promise.all(actions)
      .then(results => {
        results.forEach(result => {
          expect(result).toBeDefined()
        })
      })
  })
})

describe('error testing', () => {
  it('should return an error if amaasHostName is not set', () => {
    const amaasHostName = ''
    const error = new Error('Failed to create scan client. Could not parse target name ""')
    expect(() => {
      const amaasScanClient = new AmaasGrpcClient(amaasHostName, authKey)
      expect(amaasScanClient).toBeUndefined()
    }).toThrowError(error)
  })

  it('should return an error when incorrect TLS protocol is used', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey)
    expect(amaasGrpcClient).toBeDefined()
    const error = new Error('Service is not reachable. No connection established')
    await expect(async () => {
      await amaasGrpcClient.scanFile(filesToScan[0])
    }).rejects.toEqual(error)
    amaasGrpcClient.close()
  })

  it('should return an error when deadline exceeded', async () => {
    const deadline = 0
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey, deadline)
    expect(amaasGrpcClient).toBeDefined()
    const error = new Error('The request deadline was exceeded. Deadline exceeded')
    await expect(async () => {
      await amaasGrpcClient.scanFile(filesToScan[0])
    }).rejects.toEqual(error)
    amaasGrpcClient.close()
  })

  it('should return an error with non-exist file', async () => {
    const amaasGrpcClient = new AmaasGrpcClient(amaasHostName, authKey)
    expect(amaasGrpcClient).toBeDefined()
    const fileName = 'a-file-that-does-not-exist.txt'
    const error = new Error(`Failed to open file. ENOENT: no such file or directory, stat '${fileName}'`)
    await expect(async () => {
      await amaasGrpcClient.scanFile(fileName)
    }).rejects.toEqual(error)
    amaasGrpcClient.close()
  })
})

describe('isJWT function testing', () => {
  it('isJWT should return false for key not in correct JWT format', async () => {
    const key = generateJwtToken('invalid-format')
    const isJwt = isJWT(key)
    expect(isJwt).toBe(false)
  })

  it('isJWT should return true for key in correct C1 JWT token format', async () => {
    const key = generateJwtToken()
    const isJwt = isJWT(key)
    expect(isJwt).toBe(true)
  })

  it('isJWT should return false if the first part of key is not a JSON', async () => {
    const key = generateJwtToken('not-json')
    const isJwt = isJWT(key)
    expect(isJwt).toBe(false)
  })

  it('isJWT should return false if the first part of key is a JSON but does not have attribute alg', async () => {
    const key = generateJwtToken('invalid')
    const isJwt = isJWT(key)
    expect(isJwt).toBe(false)
  })
})
